# Distributed Public Key Infrastructure (DPKI)

## Context

Like most other distributed systems, Holochain fundamentally relies on public key cryptography. Among other uses, Holochain nodes are identified by their public keys, and thus provenance of messages from nodes can be checked simply by checking a message signature against the node's identifier.  This fundamental use requires nodes to keep the private key secret, lest the node's very agency be compromised.  Keeping such secrets in the digital age is a non-trivial problem.  Additionally, distributed systems create a context of a profusion of nodes with multiple public keys, many of which may wish to be identified as being under the control a of a single actor.  Solutions to this need create yet another layer of keys which sign other keys, and the management of all this can become quite complex.

Addressing these needs is the function of Public Key Infrastructure, and in our case, because we use the power of Holochain itself to do this, a Distributed Public Key Infrastructure: DPKI.

## Requirements

DPKI needs to fulfill at least the following design requirements:

1. Provide a way create new keys for nodes.
2. Provide a way to revoke compromised keys and re-issue keys for a node.
3. Provide a way to verify the provenance of keys by grouping them as originating from a single actor.
4. Securely manage the private keys.
5. Reliably distribute and make available information about public keys.

In designing a solution for DPKI we recognize that this is a complex and difficult enough problem that any solution will need to evolve, and in fact there will be multiple solutions necessary for different contexts.  Thus, we have built into the Holochain conductor a simple interface for the fundamental needed functions, e.g. creating new keys when installing a DNA for the first time, that can then be implemented by specialized DPKI applications.  Furthermore we've implemented a reference implementation of a Holochain based DPKI application, which we call DeepKey.

## DeepKey

To deliver on the basics of Distributed Public Key Infrastructure, we need a way to generate keys of various types (revocation, identity, encryption, signing) from seeds, and we need to be able to generate such seeds from primary seeds, so that a human agent can create related "device agents" provably under their control.

After studying a number of uses cases, including initial sign-up, key revocation, etc, the central insight we came to was the need to create a Hierarchical Deterministic Key generation system, based on a Primary Seed, from which additional seeds can be generated which then are in turn used to actually generate many key-pairs.  This allows us, by-convention, to use the first seed generated by the Primary seed as the seed for revocation keys, and subsequent seeds as seeds for keys of separate Holochain devices that can be proven to be under the control of the holder of Primary Seed.

DeepKey

TODO: merge the various docs we developed to explain DeepKey here.
- https://medium.com/holochain/part-2-holochain-holo-accounts-cryptographic-key-management-and-deepkey-bf32ee91af65
- https://hackmd.io/UbfvwQdJRKaAHI9Xa7F3VA?view
- https://hackmd.io/8c8rZCyaTTqH_7TIBVtEUQ
- https://hackmd.io/oobu0sKMSMadLXza4rHY_g

## Technical Details

### Keystore
For each Holochain DNA instance, the Conductor maintains a Keystore, which holds "secrets" (seeds and keys) needed for cryptographic signing and encrypting. Each of the secrets in the Keystore is associated with a string which is a handle needed when using that secret for some cryptographic operation.  Our cryptographic implementation is based on libsodium, and the seeds use their notions of context and index for key derivation paths.  This implementation allows DNA developers to securely call cryptographic functions from WASM which will be executed in the conductor's secure memory space when actually doing the cryptographic processing.

Decrypting a secret from the keystore invokes a passphrase manager service, which is used to collect the passphrase from some end-user.

### Flows
TODO

#### Bootstrap
TODO: flesh out

1. Agent context generates initial keystore contents and config file with dpki section
2. If dpki section exists, conductor calls `is_initialized` on the named dpki instance, and if not, calls `init()` with the given parameters.

#### Instance Creation
1. If config has a dpki section, then all new instance keystore creation is is delegated to the dpki app using the `create_agent_key()` function

#### Instance Key Revocation
TODO

### DPKI Interface

The Holochain conductor expects the following exposed functions to exist in any dpki application so that it can call them at various times to manage keys and identity.

- `init(params)` [here: params=Option<RootKeysetId>] :  Called during bootstrap with initialization parameters retrieved from the DPKI configuration.  This function is only called if a prior call to `is_initialied()` returned false.
- `is_initialized()` -> bool : Should return a boolean value if the DPKI DNA has been initialized or not
- `get_root_keyset_id()` -> RootKeysetId : Should return a root keyset id that identifies which identity group this instance of the DPKI app is part of.
- `create_agent_key(agent_name)` :  Called any time the conductor creates a new DNA instance. Should create a keystore record for the instance.

TODO: add more functions for the trait.
