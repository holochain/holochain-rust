<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>App Entry Type Definitions - The Holochain Guidebook</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="../welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li><a href="../overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li><a href="../how_to_contribute.html"><strong aria-hidden="true">1.2.</strong> How to contribute</a></li></ol></li><li><a href="../planning_a_dapp.html"><strong aria-hidden="true">2.</strong> Planning a dApp</a></li><li><a href="../building_apps.html"><strong aria-hidden="true">3.</strong> Building Holochain Apps: Intro</a></li><li><ol class="section"><li><a href="../building_for_different_platforms.html"><strong aria-hidden="true">3.1.</strong> Building for Different Platforms</a></li><li><a href="../intro_to_dna_config.html"><strong aria-hidden="true">3.2.</strong> Intro to DNA: Configuration</a></li><li><a href="../intro_to_dna_code.html"><strong aria-hidden="true">3.3.</strong> Intro to DNA: Code</a></li><li><a href="../intro_to_command_line_tools.html"><strong aria-hidden="true">3.4.</strong> Intro to Command Line Tools</a></li><li><a href="../new_project.html"><strong aria-hidden="true">3.5.</strong> Create A New Project</a></li><li><a href="../project_source_folders.html"><strong aria-hidden="true">3.6.</strong> Project Source Folders</a></li><li><a href="../configuring_an_app.html"><strong aria-hidden="true">3.7.</strong> Configuring an App</a></li><li><a href="../zome/rust.html"><strong aria-hidden="true">3.8.</strong> Writing in Rust</a></li><li><a href="../zome/assemblyscript.html"><strong aria-hidden="true">3.9.</strong> Writing in Assemblyscript</a></li><li><a href="../zome/intro_to_webassembly.html"><strong aria-hidden="true">3.10.</strong> Intro to WebAssembly</a></li><li><a href="../alpha_migrate.html"><strong aria-hidden="true">3.11.</strong> Updating to Alpha 2</a></li><li><a href="../built_with_holochain.html"><strong aria-hidden="true">3.12.</strong> Built With Holochain</a></li></ol></li><li><a href="../zome/welcome.html"><strong aria-hidden="true">4.</strong> Building Holochain Apps: Zome Code</a></li><li><ol class="section"><li><a href="../zome/adding_a_zome.html"><strong aria-hidden="true">4.1.</strong> Adding a Zome</a></li><li><a href="../zome/intro_to_hdk.html"><strong aria-hidden="true">4.2.</strong> Intro to HDK</a></li><li><a href="../zome/define_zome.html"><strong aria-hidden="true">4.3.</strong> Intro to Zome Definition</a></li><li><a href="../zome/entry_type_definitions.html" class="active"><strong aria-hidden="true">4.4.</strong> App Entry Type Definitions</a></li><li><a href="../zome/genesis.html"><strong aria-hidden="true">4.5.</strong> Genesis</a></li><li><a href="../zome/zome_functions.html"><strong aria-hidden="true">4.6.</strong> Zome Functions</a></li><li><a href="../zome/capabilities.html"><strong aria-hidden="true">4.7.</strong> Capabilities</a></li><li><a href="../zome/read_and_write.html"><strong aria-hidden="true">4.8.</strong> (E) Read &amp; Write Data Operations</a></li><li><a href="../zome/entry_validation.html"><strong aria-hidden="true">4.9.</strong> (E) Entry Validation</a></li><li><a href="../zome/linking.html"><strong aria-hidden="true">4.10.</strong> (E) Linking</a></li><li><a href="../zome/node_to_node_messages.html"><strong aria-hidden="true">4.11.</strong> (E) Node to Node Messaging</a></li><li><a href="../zome/calling_other_zomes.html"><strong aria-hidden="true">4.12.</strong> (E) Calling Other Zomes</a></li><li><a href="../zome/signatures.html"><strong aria-hidden="true">4.13.</strong> (E) Cryptographic Signatures</a></li><li><a href="../zome/bundling.html"><strong aria-hidden="true">4.14.</strong> (E) Bundling</a></li><li><a href="../zome/emitting_signals.html"><strong aria-hidden="true">4.15.</strong> (E) Emitting Signals</a></li><li><a href="../zome/dna_variables.html"><strong aria-hidden="true">4.16.</strong> API DNA Variables</a></li><li><a href="../zome/api_functions.html"><strong aria-hidden="true">4.17.</strong> List of API Functions</a></li></ol></li><li><a href="../packaging.html"><strong aria-hidden="true">5.</strong> Building Holochain Apps: Packaging</a></li><li><ol class="section"><li><a href="../build_files.html"><strong aria-hidden="true">5.1.</strong> .build Files</a></li><li><a href="../hcignore_files.html"><strong aria-hidden="true">5.2.</strong> .hcignore Files</a></li></ol></li><li><a href="../intro_to_testing.html"><strong aria-hidden="true">6.</strong> Building Holochain Apps: Testing</a></li><li><ol class="section"><li><a href="../running_tests.html"><strong aria-hidden="true">6.1.</strong> Running Tests</a></li><li><a href="../intro_to_holochain_nodejs.html"><strong aria-hidden="true">6.2.</strong> Intro to holochain-nodejs</a></li><li><a href="../testing_configuration.html"><strong aria-hidden="true">6.3.</strong> Configuration</a></li><li><ol class="section"><li><a href="../configuration_alternatives.html"><strong aria-hidden="true">6.3.1.</strong> Configuration Alternatives</a></li></ol></li><li><a href="../managing_the_conductor.html"><strong aria-hidden="true">6.4.</strong> Managing the Conductor</a></li><li><a href="../nodejs_calling_zome_functions.html"><strong aria-hidden="true">6.5.</strong> Calling Zome Functions</a></li><li><a href="../testing_checking_results.html"><strong aria-hidden="true">6.6.</strong> (E) Checking Results</a></li><li><a href="../introspecting_instances.html"><strong aria-hidden="true">6.7.</strong> Introspecting Instances</a></li><li><a href="../scenario_testing.html"><strong aria-hidden="true">6.8.</strong> Scenario Testing</a></li><li><a href="../handling_async.html"><strong aria-hidden="true">6.9.</strong> Handling Networking Asynchronicity</a></li><li><a href="../other_test_harnesses.html"><strong aria-hidden="true">6.10.</strong> Other Test Harnesses</a></li></ol></li><li><a href="../conductors.html"><strong aria-hidden="true">7.</strong> Running Holochain Apps: Conductors</a></li><li><ol class="section"><li><a href="../development_conductor.html"><strong aria-hidden="true">7.1.</strong> Development Conductor</a></li><li><ol class="section"><li><a href="../hc_configuring_networking.html"><strong aria-hidden="true">7.1.1.</strong> Configuring Networking</a></li></ol></li><li><a href="../production_conductor.html"><strong aria-hidden="true">7.2.</strong> Production Conductor</a></li><li><ol class="section"><li><a href="../intro_to_toml_config.html"><strong aria-hidden="true">7.2.1.</strong> Intro to TOML Config Files</a></li><li><a href="../conductor_agents.html"><strong aria-hidden="true">7.2.2.</strong> Agents</a></li><li><a href="../conductor_dnas.html"><strong aria-hidden="true">7.2.3.</strong> DNAs</a></li><li><a href="../conductor_instances.html"><strong aria-hidden="true">7.2.4.</strong> Instances</a></li><li><a href="../conductor_interfaces.html"><strong aria-hidden="true">7.2.5.</strong> Interfaces</a></li><li><a href="../conductor_bridges.html"><strong aria-hidden="true">7.2.6.</strong> Bridges</a></li><li><a href="../conductor_ui_bundles.html"><strong aria-hidden="true">7.2.7.</strong> UI Bundles</a></li><li><a href="../conductor_ui_interfaces.html"><strong aria-hidden="true">7.2.8.</strong> UI Interfaces</a></li><li><a href="../conductor_logging.html"><strong aria-hidden="true">7.2.9.</strong> Logging</a></li><li><a href="../conductor_networking.html"><strong aria-hidden="true">7.2.10.</strong> Networking</a></li><li><a href="../conductor_persistence_dir.html"><strong aria-hidden="true">7.2.11.</strong> Persistence Directory</a></li></ol></li><li><a href="../json_rpc_interfaces.html"><strong aria-hidden="true">7.3.</strong> Intro to JSON-RPC Interfaces</a></li><li><a href="../conductor_json_rpc_api.html"><strong aria-hidden="true">7.4.</strong> Conductor JSON-RPC API</a></li><li><ol class="section"><li><a href="../json_rpc_http.html"><strong aria-hidden="true">7.4.1.</strong> HTTP</a></li><li><a href="../json_rpc_websockets.html"><strong aria-hidden="true">7.4.2.</strong> WebSockets</a></li></ol></li><li><a href="../conductor_admin.html"><strong aria-hidden="true">7.5.</strong> Conductor Admin</a></li></ol></li><li><a href="../apps_user_interfaces.html"><strong aria-hidden="true">8.</strong> Building Holochain Apps: User Interfaces</a></li><li><a href="../bridging.html"><strong aria-hidden="true">9.</strong> (E) Building Holochain Apps: Briding</a></li><li><a href="../live_hc_apps.html"><strong aria-hidden="true">10.</strong> (E) Going Live with Holochain Apps</a></li><li><ol class="section"><li><a href="../creating_versioned_releases.html"><strong aria-hidden="true">10.1.</strong> (E) Creating Versioned Releases</a></li></ol></li><li><a href="../apps_advanced_topics.html"><strong aria-hidden="true">11.</strong> (E) Building Holochain Apps: Advanced Topics</a></li><li><ol class="section"><li><a href="../json_string.html"><strong aria-hidden="true">11.1.</strong> Understanding JsonString</a></li><li><a href="../building_for_android.html"><strong aria-hidden="true">11.2.</strong> Building For Android</a></li></ol></li><li><a href="../extending_holochain.html"><strong aria-hidden="true">12.</strong> (E) Extending Holochain</a></li><li><ol class="section"><li><a href="../embedding_holochain.html"><strong aria-hidden="true">12.1.</strong> (E) Embedding Holochain</a></li><li><ol class="section"><li><a href="../core_api.html"><strong aria-hidden="true">12.1.1.</strong> (E) Core API</a></li></ol></li><li><a href="../naming_conventions.html"><strong aria-hidden="true">12.2.</strong> Naming conventions</a></li><li><a href="../writing_development_kit.html"><strong aria-hidden="true">12.3.</strong> Writing a Development Kit (HDK)</a></li><li><a href="../zome/implementation.html"><strong aria-hidden="true">12.4.</strong> Implementing Zome API functions</a></li><li><a href="../state_actions.html"><strong aria-hidden="true">12.5.</strong> Redux Architecture</a></li><li><ol class="section"><li><a href="../state/actions.html"><strong aria-hidden="true">12.5.1.</strong> State actions</a></li></ol></li><li><a href="../state/actors.html"><strong aria-hidden="true">12.6.</strong> State actors</a></li></ol></li><li><a href="../faq.html"><strong aria-hidden="true">13.</strong> FAQ</a></li><li><a href="../glossary.html"><strong aria-hidden="true">14.</strong> (E) Glossary</a></li><li><ol class="section"><li><a href="../agent.html"><strong aria-hidden="true">14.1.</strong> (E) Agent</a></li><li><a href="../keys.html"><strong aria-hidden="true">14.2.</strong> (E) Keys</a></li><li><a href="../dna.html"><strong aria-hidden="true">14.3.</strong> (E) DNA</a></li><li><a href="../zome.html"><strong aria-hidden="true">14.4.</strong> (E) Zome</a></li><li><a href="../source_chain.html"><strong aria-hidden="true">14.5.</strong> (E) Source Chain</a></li><li><a href="../distributed_hash_table.html"><strong aria-hidden="true">14.6.</strong> Distributed Hash Table</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                            <a href="https://github.com/holochain/holochain-rust/edit/develop/doc/holochain_101/src/zome/entry_type_definitions.md">
                                <i class="fa fa-edit"></i>
                            </a>
                        </div>

                        <h1 class="menu-title">The Holochain Guidebook</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#app-entry-type-definitions" id="app-entry-type-definitions"><h1>App Entry Type Definitions</h1></a>
<p>An &quot;entry&quot; is a data element that an agent authors to their source-chain (stored on their local device), which is then propagated to peers. The entry is backed by a &quot;chain header&quot;, which is the data element used for verification of the integrity of itself, as well as the entry.</p>
<p>Entries are a fundamental, primitive type within Holochain. Entries are an abstraction, they can technically be persisted to a device in a variety of ways, using a variety of databases, which can be as simple as files in the file system.</p>
<p>There are types of entries which cannot be written to the chain by users of an application. These are generally called system entries. They include DNA, and initial Agent entries, which are always the first two entries written to a chain.</p>
<p>There are a special type of entries called App Entries. These are entries which are created through the active use of an application by a user. They must have an entry type which, rather than being system defined, is defined by the Zome developer.</p>
<a class="header" href="#defining-app-entry-types" id="defining-app-entry-types"><h2>Defining App Entry Types</h2></a>
<p>Creating a Zome for a hApp will almost always involve defining app entry types for that Zome. This means looking closely at the data model.</p>
<p>What types of data will the Zome be designed to handle? Is it dealing in &quot;users&quot;, &quot;transactions&quot;, &quot;friendships&quot;, &quot;tasks&quot;, or what? These will be the entry types needing definition in a Zome.</p>
<p>Broadly speaking, when defining the entry type, the developer of a Zome is designing the behaviour and generic properties of data of that type. This includes these important aspects:</p>
<ul>
<li>how that data is shared, or not, with peers</li>
<li>the schema for entries of the type</li>
<li>custom validation behaviour for entries of the type</li>
<li>types of relationships (links) that can exist between entry types</li>
</ul>
<p>An entry type is given a name that is used when an agent is attempting to write an entry to the chain. That's how Holochain knows what to do with the data for the entry that it has been given.</p>
<p>An entry type should also be given a basic description so that other people reading it understand the use of the entry type.</p>
<p>A third important property is <code>sharing</code>. The primary options for this at this time are 'Private' and 'Public'. Private means entries of this type will stay only the device of the author. Public means entries of this type will be gossiped to other peers sharing copies of the DNA. Public does NOT mean that it will be shared publicly on the internet.</p>
<p>Examining a <code>.dna.json</code> file closely, nested within the JSON configuration for a Zome, for an entry type you might see something like the following:</p>
<pre><code class="language-json">&quot;entry_types&quot;: [
    {
        &quot;entry_type_name&quot;: &quot;post&quot;,
        &quot;description&quot;: &quot;A blog post entry which has an author&quot;,
        &quot;sharing&quot;: &quot;public&quot;,
        &quot;links_to&quot;: []
    }
]
</code></pre>
<p>This is a Zome that implements only a single entry type, <code>post</code>.</p>
<p>These values are likely not to be modified within a JSON file, but within some code itself, where the entry type is defined. The validation rules for the entry type, will of course be defined within the code as well. Since this can be a complex topic, defining the validation logic has <a href="./entry_validation.html">its' own article</a>.</p>
<p>Setting up the entry types for a Zome is an often logical starting point when creating a Zome.</p>
<a class="header" href="#building-in-rust-defining-an-entry-type" id="building-in-rust-defining-an-entry-type"><h2>Building in Rust: Defining an Entry Type</h2></a>
<p>Recall that in <a href="./define_zome.html#building-in-rust-define_zome">define_zome!</a>, there was an array called <code>entries</code>. The most minimalistic Zome could look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate hdk;

define_zome! {
    entries: []

    genesis: || {
        Ok(())
    }

    functions: []

    traits: {}
}
#}</code></pre></pre>
<p><code>entries</code> is where we will populate the Zome with entry type definitions. It expects an array of <code>ValidatingEntryType</code>. So how can one be created?</p>
<p>Easy: the <code>entry!</code> macro. It can be used to encapsulate everything needed to define an entry type. All of the following must be defined:</p>
<hr />
<p><strong>name</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
entry!(
    name: &quot;post&quot;,
    ...
)
#}</code></pre></pre>
<p>This should be a machine-readable name for the entry type. Spaces should not be used. What will the entry type be that will be given when new entries are being created?</p>
<hr />
<p><strong>description</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
entry!(
    ...
    description: &quot;A blog post entry which has an author&quot;,
    ...
)
#}</code></pre></pre>
<p>This should be a human-readable explanation of the meaning or role of this entry type.</p>
<hr />
<p><strong>sharing</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use hdk::holochain_core_types::dna::entry_types::Sharing;

entry!(
    ...
    sharing: Sharing::Public,
    ...
)
#}</code></pre></pre>
<p>As mentioned above, sharing refers to whether entries of this type are private to their author, or whether they will be gossiped to other peers to hold copies of. The value must be referenced from an <a href="/api/latest/holochain_core_types/dna/entry_types/enum.Sharing.html">enum in the HDK</a>. Holochain currently supports the first two values in the enum: Public, and Private.</p>
<hr />
<p><strong>native_type</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(try_from)]
#fn main() {
extern crate serde;
extern crate serde_json;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate holochain_core_types_derive;

#[derive(Serialize, Deserialize, Debug, DefaultJson)]
struct Post {
    content: String,
    date_created: String,
}

entry!(
    ...
    native_type: Post,
    ...
)
#}</code></pre></pre>
<p>Clearly, <code>native_type</code> is where things start to get interesting. It requires the introduction of quite a number of dependencies, first of all. Why is that?</p>
<p>It is important to remember that the Rust code of a Zome is compiled into WASM before it can be executed by Holochain. This introduces a certain constraint. How is data passed between Holochain, and the WASM Zome code? Answer: it is stored in the WASM memory as stringified JSON data, and accessed by the WASM code and by Holochain, running the WASM interpreter.</p>
<p>JSON was chosen as the interchange format because it is so universal, and almost all languages have serializers and parsers. Rust's is called <code>serde</code>. The three <code>serde</code> related dependencies all relate to the need to serialize to and from JSON within Zomes.</p>
<p>Note that the top line in the snippet above is important. It switches on a Rust feature that would otherwise be off, allowing attempted conversions between types, which is exactly what the JSON parsing is doing.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(try_from)]
#fn main() {
#}</code></pre></pre>
<p>Additionally, the HDK offers built-in conversion functions from JSON strings to Entry structs. This comes from the <code>DefaultJson</code> <a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive</a>.</p>
<p>Every struct used as a <code>native_type</code> reference should include all 4 derives, as in the example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Serialize, Deserialize, Debug, DefaultJson)]
#}</code></pre></pre>
<p><code>Serialize</code> and <code>Deserialize</code> come from <code>serde_derive</code>, and <code>DefaultJson</code> comes from <code>holochain_core_types_derive</code>.</p>
<p>Then there is the struct itself. This is the real type definition, because it defines the schema. It is simply a list of property names, the 'keys', and the types of values expected, which should be set to one of the primitive types of the language. This will tell <code>serde</code> how to parse JSON string inputs into the type. Note that conversion from JSON strings into the struct type can easily fail, in particular if the proper keys are not present on the input.</p>
<hr />
<p><strong>validation_package</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use hdk::ValidationPackageDefinition;

entry!(
    ...
    validation_package: || {
        ValidationPackageDefinition::Entry
    },
    ...
)
#}</code></pre></pre>
<p>At the moment, what <code>validation_package</code> is will not be covered in great detail. In short, for a peer to perform validation of an entry from another peer, varying degrees of metadata from the original author of the entry might be needed. <code>validation_package</code> refers to the carrier for that extra metadata.</p>
<p>Looking at the above code, there is a required import from the HDK needed for use in <code>validation_package</code>, and that's the enum <code>ValidationPackageDefinition</code>. The value of <code>validation_package</code> is a function that takes no arguments. It will be called as a callback by Holochain. The result should be a value from the <code>ValidationPackageDefinition</code> enum, whose values can be <a href="https://developer.holochain.org/api/0.0.3/hdk/enum.ValidationPackageDefinition.html">seen here</a>. In the example, and as the most basic option, simply use <code>Entry</code>, which means no extra metadata beyond the entry itself is needed.</p>
<p>Further reading is <a href="./entry_validation.html">here</a>.</p>
<hr />
<p><strong>validation</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use hdk::ValidationData;

entry!(
    ...
    validation: |_post: Post, _validation_data: ValidationData| {
        Ok(())
    }
)
#}</code></pre></pre>
<p><code>validation</code> is the last required property of <code>entry!</code>. Because it is such an important aspect, it has <a href="./entry_validation.html">its' own in depth article</a>.</p>
<p>It is a callback that Holochain will call during different moments in the lifecycle of an entry, in order to confirm which action to take with the entry, depending on its' validity. It will be called with two arguments, the first representing the struct of the entry itself, and the second a struct holding extra metadata that can be used for validation, including, if it was requested, the <code>validation_package</code>.</p>
<p>The callback should return a Rust <code>Result</code> type. This is seen in <code>Ok(())</code>. The example above is the simplest possible <code>validation</code> function, since it doesn't perform any real logic. While this is ok in theory, great caution should be taken with the validation rules, and further reading is recommended.</p>
<p><code>validation</code> for a <code>ValidatingEntryType</code> should either return <code>Ok(())</code> or an <code>Err</code> containing the string explaining why validation failed.</p>
<p>The validity of an entry is therefore defined by the author of a Zome. First of all, data which doesn't conform to the schema defined by the <code>native_type</code> will fail, but <code>validation</code> allows for further rules to be defined.</p>
<p>Note that not only the entry author will call this function to validate the entry during its' creation, but other peers will call this function to validate the entry when it is requested via the network that they hold a copy of it. <em>This is at the heart of how Holochain functions as peer-to-peer data integrity layer.</em></p>
<p>Further reading can be found <a href="./entry_validation.html">here</a>.</p>
<hr />
<a class="header" href="#putting-it-all-together" id="putting-it-all-together"><h3>Putting It All Together</h3></a>
<p>Taken all together, use of the <code>entry!</code> macro may look something like the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
...
entry!(
    name: &quot;post&quot;,
    description: &quot;A blog post entry which has an author&quot;,
    sharing: Sharing::Public,
    native_type: Post,
    validation_package: || {
        ValidationPackageDefinition::Entry
    },
    validation: |_post: Post, _validation_data: ValidationData| {
        Ok(())
    }
)
#}</code></pre></pre>
<p>This can be embedded directly inside of the entries array of the <code>define_zome!</code>, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
...
define_zome! {
    entries: [
        entry!(
            name: &quot;post&quot;,
            description: &quot;A blog post entry which has an author&quot;,
            sharing: Sharing::Public,
            native_type: Post,
            validation_package: || {
                ValidationPackageDefinition::Entry
            },
            validation: |_post: Post, _validation_data: ValidationData| {
                Ok(())
            }
        )
    ]

    genesis: || {
        Ok(())
    }

    functions: []

    capabilitites: {}
}
#}</code></pre></pre>
<p>If there is only entry type, this can be fine, but if there are multiple, this can hurt readability of the source code. You can wrap the entry type definition in a function, and call it in <code>define_zome!</code>, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
...
fn post_definition() -&gt; ValidatingEntryType {
    entry!(
        name: &quot;post&quot;,
        description: &quot;A blog post entry which has an author&quot;,
        sharing: Sharing::Public,
        native_type: Post,

        validation_package: || {
            hdk::ValidationPackageDefinition::Entry
        },

        validation: |_post: Post, _validation_data: hdk::ValidationData| {
            Ok(())
        }
    )
}

define_zome! {
    entries: [
        post_definition()
    ]

    genesis: || {
        Ok(())
    }

    functions: []

    capabilitites: {}
}
#}</code></pre></pre>
<p>Use of this technique can help you write clean, modular code.</p>
<p>If you want to look closely at a complete example of the use of <code>entry!</code> in a Zome, check out the <a href="https://developer.holochain.org/api/0.0.3/hdk/macro.entry.html">API reference</a>, or the <a href="https://github.com/holochain/holochain-rust/blob/v0.0.3/app_spec/zomes/blog/code/src/post.rs">&quot;app-spec&quot; example app</a>.</p>
<a class="header" href="#summary" id="summary"><h4>Summary</h4></a>
<p>This is still a pretty minimal Zome, since it doesn't have any functions yet, and the most basic <code>genesis</code> behaviour, so read on to learn about how to work with those aspects of <code>define_zome!</code>.</p>

                        <hr />
                        <a href="https://github.com/holochain/holochain-rust/edit/develop/doc/holochain_101/src/zome/entry_type_definitions.md">suggest an edit</a>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../zome/define_zome.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../zome/genesis.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../zome/define_zome.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../zome/genesis.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
